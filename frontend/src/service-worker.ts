/// <reference lib="webworker" />
/**
 * Service Worker for OpsPlatform PWA
 * Implements offline-first caching strategy using Workbox
 */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all app shell assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// App Shell - Cache First
const fileExtensionRegexp = /\.(js|css|png|jpg|jpeg|svg|gif|woff|woff2|ttf|eot)$/;
registerRoute(
    ({ url }: { url: URL }) => {
        // Skip API requests
        if (url.pathname.startsWith('/api')) {
            return false;
        }

        // Cache static assets
        return fileExtensionRegexp.test(url.pathname);
    },
    new CacheFirst({
        cacheName: 'static-resources',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
            }),
        ],
    })
);

// API - Network First with offline fallback
registerRoute(
    ({ url }) => url.pathname.startsWith('/api'),
    new NetworkFirst({
        cacheName: 'api-cache',
        networkTimeoutSeconds: 10,
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 5 * 60, // 5 minutes
            }),
        ],
    })
);

// Images - Stale While Revalidate
registerRoute(
    ({ request }) => request.destination === 'image',
    new StaleWhileRevalidate({
        cacheName: 'images',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
            }),
        ],
    })
);

// Navigate fallback - Serve app shell for navigation requests
const handler = createHandlerBoundToURL('/index.html');

registerRoute(
    ({ request, url }) => {
        return request.mode === 'navigate' && !url.pathname.startsWith('/api');
    },
    handler
);

// Background Sync for failed requests
self.addEventListener('sync', (event: any) => {
    if (event.tag === 'sync-operations') {
        event.waitUntil(syncPendingOperations());
    }
});

async function syncPendingOperations() {
    // This will be called when the browser thinks the user has connectivity
    // We'll trigger sync from the main app via the sync queue
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
        client.postMessage({
            type: 'SYNC_TRIGGERED',
            timestamp: Date.now()
        });
    });
}

// Listen for skip waiting message
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

// Notify clients about updates
self.addEventListener('activate', (event: ExtendableEvent) => {
    event.waitUntil(
        (async () => {
            const clients = await self.clients.matchAll();
            clients.forEach(client => {
                client.postMessage({
                    type: 'SW_ACTIVATED',
                    timestamp: Date.now()
                });
            });
        })()
    );
});

console.log('Service Worker loaded and ready!');
